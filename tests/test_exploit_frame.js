const { io } = require('socket.io-client');
const SERVER = 'http://localhost:3000';

let passed = 0, failed = 0;
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

async function testLegitThenExploit() {
    console.log('\nðŸŽ® FRAME TEST: Legit User followed by Hacker');
    const username = 'FRAME_VICTIM_' + Date.now();
    let legitScore = 0;

    return new Promise(async (resolve) => {
        let s1 = io(SERVER, { transports: ['websocket'], forceNew: true });
        s1.on('connect', () => {
            s1.once('gameStarted', async (data) => {
                for (let i = 0; i < 40; i++) {
                    s1.emit('keyPressBatch', { keys: ['A'], token: data.token });
                    await sleep(60);
                }
                s1.emit('clientGameEnd');
            });
            s1.emit('startGame', { name: username, mode: 'classic' });
        });

        await new Promise(r => {
            s1.on('gameOver', (data) => {
                legitScore = data.finalScore;
                console.log(`   Legit Score: ${legitScore}`);
                if (data.profiles.length > 0 && !data.profiles.some(p => p.isCheater)) {
                    console.log('  âœ… PASS: Legit run has no cheater profiles'); passed++;
                } else {
                    console.log('  âŒ FAIL: Legit run HAS cheater profiles'); failed++;
                }
                s1.disconnect();
                r();
            });
        });

        await sleep(1000);

        let s2 = io(SERVER, { transports: ['websocket'], forceNew: true });
        let exploitKilled = false;

        s2.on('connect', () => {
            s2.once('gameStarted', async (data) => {
                const start = Date.now();
                while (Date.now() - start < 2000 && !exploitKilled) {
                    const batch = new Array(80).fill('KeyA');
                    s2.emit('keyPressBatch', { keys: batch, token: data.token });
                    await sleep(4);
                }
            });
            s2.emit('startGame', { name: username, mode: 'classic' });
        });

        await new Promise(r => {
            s2.on('gameOver', (data) => {
                exploitKilled = true;
                const isPersonalBest = data.isPersonalBest;
                const runProfiles = (data.runProfiles || []);
                const currentProfiles = (data.profiles || []);
                console.log(`   Exploit returned. Run profiles: ${runProfiles.map(p => p.title).join(', ')}`);

                if (!runProfiles.some(p => p.isCheater)) {
                    console.log('  âŒ FAIL: Exploit run was NOT flagged as cheater'); failed++;
                } else {
                    console.log('  âœ… PASS: Exploit run was flagged as cheater'); passed++;
                }

                if (isPersonalBest) {
                    console.log('  âŒ FAIL: Exploit run OVERWROTE the personal best'); failed++;
                } else {
                    console.log('  âœ… PASS: Exploit run did NOT overwrite the personal best'); passed++;
                }

                if (currentProfiles.some(p => p.isCheater)) {
                    console.log('  âŒ FAIL: Cheater profile WAS saved to the user permanent profiles'); failed++;
                } else {
                    console.log('  âœ… PASS: Cheater profile was NOT saved to the user permanent profiles'); passed++;
                }
                s2.disconnect();
                r();
            });
        });
        resolve();
    });
}

testLegitThenExploit().then(() => {
    console.log(`\nRESULTS: ${passed} passed, ${failed} failed`);
    process.exit(failed > 0 ? 1 : 0);
}).catch(console.error);
