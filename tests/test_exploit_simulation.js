/**
 * test_exploit_simulation.js â€” Simulates the Python exploit to validate defenses.
 * Run: node tests/test_exploit_simulation.js
 * Requires server running on localhost:3000.
 */

const { io } = require('socket.io-client');
const SERVER = 'http://localhost:3000';

let passed = 0, failed = 0;
function assert(cond, label) {
    if (cond) { console.log(`  âœ… PASS: ${label}`); passed++; }
    else { console.log(`  âŒ FAIL: ${label}`); failed++; }
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Simulate the exact Python exploit
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function testExploitSimulation() {
    console.log('\nðŸ EXPLOIT SIMULATION: Python-style batch flooding');
    console.log('   Sending 80-key batches every 4-5ms (like the exploit)...\n');

    return new Promise((resolve) => {
        const socket = io(SERVER, { transports: ['websocket'], forceNew: true });
        let finalScore = null;
        let gameKilled = false;
        let batchesSent = 0;

        socket.on('connect', () => {
            // Register gameStarted BEFORE emitting
            socket.once('gameStarted', async (data) => {
                const token = data.token;
                console.log(`   Token: ${token}`);

                const keys = 'abcdefghijklmnopqrstuvwxyz'.split('');
                const start = Date.now();

                // Mimic the exploit: send batches every 4-5ms
                while (Date.now() - start < 2000 && !gameKilled) {
                    const batch = new Array(80).fill('KeyA');
                    socket.emit('keyPressBatch', { keys: batch, token });
                    batchesSent++;
                    await sleep(4 + Math.random());  // 4-5ms like the exploit
                }
                console.log(`   Sent ${batchesSent} batches before game ended`);
            });

            socket.emit('startGame', { name: 'EXPLOIT_' + Date.now(), mode: 'classic' });
        });

        socket.on('gameOver', (data) => {
            gameKilled = true;
            finalScore = data.finalScore;
            const profiles = (data.runProfiles || []).map(p => p.title);

            console.log(`\n   Final score: ${finalScore}`);
            console.log(`   Profiles: [${profiles.join(', ')}]`);
            console.log(`   Batches sent: ${batchesSent}`);

            // Without defenses, 2 seconds of flooding at 80 keys/4ms = ~40,000 keys
            // With defenses, score is capped at 300 (burst) + (2s Ã— 300 KPS) = max ~900.
            // Ceiling raised intentionally to support extreme legit players (1200+ keys in 5s).
            assert(finalScore < 1000, `Score capped well below exploit potential (got ${finalScore}, exploit could get 40000+)`);
            assert(profiles.includes('The Overloader') || profiles.includes('Suspected Cheater'), 'Caught and assigned a cheater profile (Overloader or Suspected Cheater)');
            // The test loop keeps sending client-side even after server kills the game,
            // so batchesSent may be high â€” the real test is the crushed score.

            socket.disconnect();
            resolve();
        });
    });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Test that normal gameplay is NOT affected
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function testNormalGameplay() {
    console.log('\nðŸŽ® NORMAL GAMEPLAY: Sending at human-like 50ms intervals');

    return new Promise((resolve) => {
        const socket = io(SERVER, { transports: ['websocket'], forceNew: true });

        socket.on('connect', () => {
            socket.once('gameStarted', async (data) => {
                const token = data.token;
                const keys = 'asdfghjkl'.split('');

                // Simulate human gameplay: ~16 KPS (1 key every 60ms)
                for (let i = 0; i < 50; i++) {
                    const batch = [keys[Math.floor(Math.random() * keys.length)]];
                    socket.emit('keyPressBatch', { keys: batch, token });
                    await sleep(60); // 60ms between keys
                }

                socket.emit('clientGameEnd');
            });

            socket.emit('startGame', { name: 'LEGIT_' + Date.now(), mode: 'classic' });
        });

        socket.on('gameOver', (data) => {
            console.log(`   Score: ${data.finalScore}`);
            assert(data.finalScore === 50, `All 50 legit keys counted (got ${data.finalScore})`);

            socket.disconnect();
            resolve();
        });
    });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function runAll() {
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('  ðŸ›¡ï¸  EXPLOIT SIMULATION vs HARDENED DEFENSES');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

    await testExploitSimulation();
    await sleep(3500); // cooldown
    await testNormalGameplay();

    console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log(`  RESULTS: ${passed} passed, ${failed} failed`);
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
    process.exit(failed > 0 ? 1 : 0);
}

runAll().catch(err => { console.error('Error:', err); process.exit(1); });
